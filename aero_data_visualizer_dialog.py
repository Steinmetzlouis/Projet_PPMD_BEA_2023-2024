# -*- coding: utf-8 -*-
"""
/***************************************************************************
 AeroDataVisualizerDialog
                                 A QGIS plugin
 This plugin allows to visualize aeronautical data
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-01-08
        git sha              : $Format:%H$
        copyright            : (C) 2024 by BEA
        email                : louise.redlinger@ensg.eu
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.core import QgsCoordinateReferenceSystem, QgsCoordinateTransform, QgsProject, QgsWkbTypes, QgsGeometry
from qgis.PyQt.QtWidgets import QWidget, QTableWidget, QTableWidgetItem, QHeaderView, QVBoxLayout, QHBoxLayout, QPushButton, QGridLayout

# Librairie saisie d'emprise (TRI A FAIRE!)
from qgis.core import QgsRectangle
from qgis.core import QgsPointXY
from qgis.PyQt.QtWidgets import QApplication, QMessageBox
from qgis.gui import QgsMapTool, QgsMapToolExtent, QgsRubberBand, QgsMapCanvas

from PyQt5.QtCore import Qt
import json
from qgis.core import QgsVectorLayer, QgsDataSourceUri, QgsProject, QgsWkbTypes

#dates
from datetime import datetime
from qgis.core import QgsDataSourceUri, QgsProject

import psycopg2
from .mytoolbox import nearest_table_date


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'aero_data_visualizer_dialog_base.ui'))





class AeroDataVisualizerDialog(QtWidgets.QDialog, FORM_CLASS):
    
    def __init__(self, iface, parent=None):
        """Constructor."""
        super(AeroDataVisualizerDialog, self).__init__(parent)
        self.iface = iface
        self.setupUi(self)
        self.setWindowFlags(Qt.Window)

        print("Bienvenue dans le bien nommé plugin AeroDataVisualizer ! ")

        self.rubberband = None
        self.mapTool = None
        self.extent = None
        self.extent_wgs84 = None
        self.date_value = None

        self.fields = None

        # Pour trouver le QTabWidget 
        self.gridLayout_snd_tab = self.findChild(QGridLayout, "gridLayout_5")
        self.tab_widget = self.findChild(QtWidgets.QTabWidget, 'tabWidget')
        self.first_tab = self.tab_widget.widget(0)
        self.snd_tab = self.tab_widget.widget(1)

        self.old_tablewidget = self.findChild(QtWidgets.QTableView, 'tableView')
        self.new_tablewidget = None
        self.visualizeButton = None

        if self.tab_widget:
            
            print("TabWidget trouvé")
            

            confirmButton = self.findChild(QtWidgets.QPushButton, 'confirmButton')
            coverageButton = self.findChild(QtWidgets.QPushButton, 'coverageButton')

            if confirmButton :

                print("Bouton 'Valider' trouvé")

                confirmButton.clicked.connect(self.on_valider_clicked)

            if coverageButton :

                print("Bouton 'Saisir emprise' trouvé")
                coverageButton.clicked.connect(self.on_saisir_emprise_clicked)
            





    def handle_extent_selected(self):
        
        #étendue
        self.extent = self.mapTool.extent()

        # Définir le système de référence source (le CRS actuel de la carte)
        source_crs = self.iface.mapCanvas().mapSettings().destinationCrs()

        # Définir le système de référence cible (WGS84)
        target_crs = QgsCoordinateReferenceSystem('EPSG:4326')  # EPSG:4326 est le code EPSG pour WGS84

        # Créer l'objet de transformation des coordonnées
        transform = QgsCoordinateTransform(source_crs, target_crs, QgsProject.instance())

        # Appliquer la transformation aux coins de l'emprise
        self.extent_wgs84 = transform.transformBoundingBox(self.extent, QgsCoordinateTransform.ForwardTransform)
        extent_wgs84_str = 'xmin: {:.2f}, ymin: {:.2f}, xmax: {:.2f}, ymax: {:.2f}'.format(
            round(self.extent_wgs84.xMinimum(), 2),
            round(self.extent_wgs84.yMinimum(), 2),
            round(self.extent_wgs84.xMaximum(), 2),
            round(self.extent_wgs84.yMaximum(), 2)
        )

        print(self.extent)
        print(self.extent_wgs84)
        print("Emprise sélectionnée (WGS84):", extent_wgs84_str)
        self.empriseLabel.setText(f'Emprise définie : {extent_wgs84_str}')

        self.mapTool.clearRubberBand()

        self.mapCanvas.setLayers(self.iface.mapCanvas().layers())
        self.mapCanvas.setExtent(self.extent)
        self.mapCanvas.setCanvasColor(Qt.white)
        self.mapCanvas.enableAntiAliasing(True)
        if self.rubberband is not None:
            self.mapCanvas.scene().removeItem(self.rubberband)
        self.rubberband = QgsRubberBand(self.mapCanvas, QgsWkbTypes.PolygonGeometry)  # polygon
        self.rubberband.setToGeometry(QgsGeometry.fromRect(self.extent), None)
        self.mapCanvas.refreshAllLayers()
        self.mapCanvas.show()

        self.showNormal()

        self.raise_()
        self.activateWindow()



    def on_valider_clicked(self):

        self.iface.mapCanvas().unsetMapTool(self.mapTool)
        
        if self.surveyDate:
            # On récupère la valeur de la date saisie
            self.date_value = self.surveyDate.date().toString("yyyy-MM-dd")


        else:
            print("Objet QDateEdit non trouvé.")

        if self.extent_wgs84 is not None :

            print("coucou")
            
            rect = self.extent_wgs84
            xmin, ymin, xmax, ymax = rect.xMinimum(), rect.yMinimum(), rect.xMaximum(), rect.yMaximum()

            # Chemin vers le fichier contenant les informations de connexion
            path = "/Users/louis/AppData/Roaming/QGIS/QGIS3/profiles/default/python/plugins/Projet_PPMD_BEA_2023-2024/id.json"

            if self.extent_wgs84 is not None:
                
                rect = self.extent_wgs84
                xmin, ymin, xmax, ymax = rect.xMinimum(), rect.yMinimum(), rect.xMaximum(), rect.yMaximum()

                conn_params = {
                    'database': "projet_BEA",
                    'user': "postgres",
                    'host': "localhost",
                    'password': "postgres",
                    'port': 5432
                }

                conn = psycopg2.connect(**conn_params)
                cursor = conn.cursor()

                # Sélectionnez les noms des tables qui commencent par "XML_SIA_"
                cursor.execute("""
                    SELECT table_name 
                    FROM information_schema.tables 
                    WHERE table_schema = 'public' 
                    AND table_name LIKE 'XML_SIA_%'
                """)

                # Récupérer les résultats de la requête
                tables = [table[0] for table in cursor.fetchall()]
                print("Tables commençant par XML_SIA_: ", tables)

                dates_formatted = []

                for table in tables:
                    # Extraire la partie de la date du nom de la table
                    date_part = table.replace("XML_SIA_", "")  # Supprimer le préfixe
                    # Convertir la partie de la date en objet datetime
                    try:
                        date_obj = datetime.strptime(date_part, "%Y_%m_%d")
                        # Formater la date au format "aaaa-mm-jj"
                        formatted_date = date_obj.strftime("%Y-%m-%d")
                        # Ajouter la date formatée à la liste dates_formatted
                        dates_formatted.append(formatted_date)
                    except ValueError:
                        print(f"Impossible de convertir la date dans le nom de la table : {table}")

                print("Dates formatées : ", dates_formatted)

                user_date = nearest_table_date(self.date_value,dates_formatted)
                print(user_date)

                #la on met le code qui fait la checklist avec tous les lk 
                
                #enveloppe pour la requete spatiale
                geom_bound = f'ST_MakeEnvelope({xmin}, {ymin}, {xmax}, {ymax}, 4326)'
                geom_col = "geometry"

                # Configuration du code de Louis
                schema = "public"  # imposé par le code de Louis

                # Construction de la requête SQL avec la date dynamique
                # sql = f'SELECT * FROM {schema}.{table} WHERE ST_Within({geom_col}, {geom_bound})'
                #sql_query = f"""SELECT lk FROM {schema}.XML_SIA_{user_date.replace('-', '_')}"""
                sql_query = f"""SELECT lk FROM {schema}."XML_SIA_{user_date.replace('-', '_')}" WHERE ST_Within({geom_col}, {geom_bound})"""

                # Exécutez la requête SQL et récupérez les noms de colonne "lk"
                cursor.execute(sql_query)

                # Récupérez tous les résultats de la requête
                lk_names = cursor.fetchall()

                fields = []
                # Affichez les noms de colonne "lk"
                for name in lk_names:
                    fields.append(name[0])
                
                self.fields = fields

                self.new_tablewidget = QTableWidget(len(self.fields), 2, self)
                self.new_tablewidget.horizontalHeader().setStretchLastSection(True)
                self.new_tablewidget.setHorizontalHeaderLabels(["", "Nom attribut"])
                for i, field_name in enumerate(self.fields):
                    item = QTableWidgetItem()
                    item.setFlags(Qt.ItemIsUserCheckable | Qt.ItemIsEnabled)
                    item.setCheckState(Qt.Unchecked)
                    self.new_tablewidget.setItem(i, 0, item)
                    self.new_tablewidget.setItem(i, 1, QTableWidgetItem(field_name))

                header = self.new_tablewidget.horizontalHeader()
                header.setSectionResizeMode(0, QHeaderView.ResizeToContents)
                header.setSectionResizeMode(1, QHeaderView.Stretch)
                self.new_tablewidget.setSizePolicy(self.old_tablewidget.sizePolicy())
                self.gridLayout_snd_tab.addWidget(self.new_tablewidget, 1, 0) # ici 1, 0 signifie que l'élément à remplacer est à la 2e ligne et 1ère colonne de la grille
                self.visualizeButton = QPushButton("Visualiser",self)
                self.gridLayout_snd_tab.addWidget(self.visualizeButton, 2, 0)

                self.visualizeButton.clicked.connect(self.on_visualiser_clicked)



                self.old_tablewidget.hide()







                




        else :

            print('non')
        
        self.tabWidget.setCurrentIndex(1)

    def on_visualiser_clicked(self):

        print("moooolllaaaa")

        liste = self.get_fields()

        print(liste)


    def get_fields(self):
        fields = []
        for row in range(self.new_tablewidget.rowCount()):
            item = self.new_tablewidget.item(row, 0)
            if item.checkState() == Qt.Checked:
                fields.append(self.new_tablewidget.item(row, 1).text())
        return fields


    def on_saisir_emprise_clicked(self):
        
        #cache la fenetre du plugin
        self.showMinimized()



        canvas = self.iface.mapCanvas()
        self.mapTool = QgsMapToolExtent(canvas)
        self.mapTool.extentChanged.connect(self.handle_extent_selected)
        canvas.setMapTool(self.mapTool)


    


    

